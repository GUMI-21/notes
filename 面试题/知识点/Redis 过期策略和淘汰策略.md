+ 过期策略
	+ 定期删除 + 惰性删除
		+ 定期删除是指redis默认每隔100ms就随机抽一些设置了过期时间的key，实际上是随机抽取一些key来检查和删除，因为性能问题。定期删除就会导致很多过期的key不会被删除掉，于是就有了惰性删除，当获取一个key的时候，redis会检查是否过期，如果过期了就不返回任何东西，删除掉key，这也是scan清缓存的原理。
		+  不过就算是这样，依然会有大量过期的key堆积在内存里面，导致内存耗尽，所以得有内存淘汰策略
	+ 内存淘汰
		+ 总结：lru，random，ttl
		+ noeviction：内存不够，写入数据直接报错
		+ allkeys-lru：内存不够，在键空间里移除最近最少使用的key，常用策略
		+ allkeys-random：随机移除
		+ volatile-lru：在设置了过期时间里的key中，移除最近最少使用的key
		+ volatile-random：在设置了过期时间的key中，随机移除
		+ volatile-ttl：在设置里过期时间的key中，移除更早设置过期时间的key
	+ LRU算法
		+ 大概如下：维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表：如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的节点，并将其从原来的位置删除，然后再插入到链表的头部。如果没在链表里：缓存没满，直接放在表头，满了，删除尾结点，放在表头，其实还是很简单的，但是需要手动实现一下！