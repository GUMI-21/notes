题目:https://www.nowcoder.com/discuss/353157951986802688
### 服务框架
##### rpc微服务框架
+ 一些概念
	+ grpc：基于HTTP 2.0协议，支持众多编程语言，“RPC协议”指的是程序如何进行网络传输和序列化，即pb结构。
	+ 完整的RPC框架：包含服务发现、负载、容错、网络传输、序列化等组件。RPC的核心是服务发现，数据流的序列化和反序列化、网络传输。
	+ 服务发现：服务注册中心，如*Zookeeper，etcd*。
	+ 使用RabiitMQ或者KAFKA：自己实现线程池，很轻松的异步处理请求。
+ 我会的：
	+ 利用统一的api_gateway服务调用各个模块的GRPC服务进行程序的解耦，改善服务负载，服务发现使用ETCD，*ZooKeeper和ETCD需要了解一下*，利用Kafka异步消费来实现异步处理请求数据，减少tcp连接数，降低接口延迟。

### 缓存
##### Redis的过期策略和淘汰策略
+ 这个问题太常见了，稍微总结一下
+ 一般要清内存了，可以跑一下scan*这个记得去看一下*，来触发过期
	+ 参考连接：https://zhuanlan.zhihu.com/p/152643114
	+ 过期策略
		+ 定期删除 + 惰性删除
		+ 定期删除是指redis默认每隔100ms就随机抽一些设置了过期时间的key，实际上是随机抽取一些key来检查和删除，因为性能问题。定期删除就会导致很多过期的key不会被删除掉，于是就有了惰性删除，当获取一个key的时候，redis会检查是否过期，如果过期了就不返回任何东西，删除掉key，这也是scan清缓存的原理。
		+ 不过就算是这样，依然会有大量过期的key堆积在内存里面，导致内存耗尽，所以得有内存淘汰策略
	+ 内存淘汰
		+ 总结：lru，random，ttl
		+ noeviction：内存不够，写入数据直接报错
		+ allkeys-lru：内存不够，在键空间里移除最近最少使用的key，常用策略
		+ allkeys-random：随机移除
		+ volatile-lru：在设置了过期时间里的key中，移除最近最少使用的key
		+ volatile-random：在设置了过期时间的key中，随机移除
		+ volatile-ttl：在设置里过期时间的key中，移除更早设置过期时间的key
	+ LRU算法
		+ 大概如下：维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表：如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的节点，并将其从原来的位置删除，然后再插入到链表的头部。如果没在链表里：缓存没满，直接放在表头，满了，删除尾结点，放在表头，其实还是很简单的，但是需要手动实现一下！

### 数据库
##### sql索引优化的问题
+ 我懂的：查sql的时候可以根据别的字段只查主键的范围再进行查询，某些情况下可以使用force on来强制依赖某一个key，使用explain。

### 消息队列
##### MQ底层数仓
+ ？没听过，MQ和Kafka都要重新研究一下，kafka遇到的问题需要总结一下

### Golang代码
##### runtime包里的方法 
+ 概念
	+ **GOMAXPROCS** 设置最大CPU运行数量，这个知道；最好在操作程序的环境变量中设置，而不是在程序中调用，会引起”Stop the World"
		+ go1.8后默认运行在多核，1.8之前需要设置
	+ **runtime.GC** 手动调用进行强制性的垃圾回收
	+ **Goexit** 退出当前goroutine (。。感觉直接return也没啥区别，defer语句都会执行)
	+ **Gosched** 当前协程让出cpu，这个一般也用不到，因为根本不知道是哪个协程在用cpu
